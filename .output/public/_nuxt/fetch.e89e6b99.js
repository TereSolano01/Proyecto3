import{s as k,v as x,x as O,y as C,z as P,u as z,A as B,B as E,C as F}from"./entry.c3a144a6.js";const M=()=>null;function A(...o){var h,p,v,m,_,D,w,b;const f=typeof o[o.length-1]=="string"?o.pop():void 0;typeof o[0]!="string"&&o.unshift(f);let[t,c,a={}]=o;if(typeof t!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof c!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");a.server=(h=a.server)!=null?h:!0,a.default=(p=a.default)!=null?p:M,a.defer&&console.warn("[useAsyncData] `defer` has been renamed to `lazy`. Support for `defer` will be removed in RC."),a.lazy=(m=(v=a.lazy)!=null?v:a.defer)!=null?m:!1,a.initialCache=(_=a.initialCache)!=null?_:!0;const e=k(),l=()=>(e.isHydrating||a.initialCache)&&e.payload.data[t]!==void 0;e._asyncData[t]||(e._asyncData[t]={data:x(l()?e.payload.data[t]:(w=(D=a.default)==null?void 0:D.call(a))!=null?w:null),pending:x(!l()),error:x((b=e.payload._errors[t])!=null?b:null)});const n={...e._asyncData[t]};n.refresh=(r={})=>e._asyncDataPromises[t]?e._asyncDataPromises[t]:r._initial&&l()?e.payload.data[t]:(n.pending.value=!0,e._asyncDataPromises[t]=new Promise((i,s)=>{try{i(c(e))}catch(u){s(u)}}).then(i=>{a.transform&&(i=a.transform(i)),a.pick&&(i=R(i,a.pick)),n.data.value=i,n.error.value=null}).catch(i=>{var s,u;n.error.value=i,n.data.value=z((u=(s=a.default)==null?void 0:s.call(a))!=null?u:null)}).finally(()=>{n.pending.value=!1,e.payload.data[t]=n.data.value,n.error.value&&(e.payload._errors[t]=!0),delete e._asyncDataPromises[t]}),e._asyncDataPromises[t]);const y=()=>n.refresh({_initial:!0}),g=a.server!==!1&&e.payload.serverRendered;{const r=B();if(r&&!r._nuxtOnBeforeMountCbs){r._nuxtOnBeforeMountCbs=[];const s=r._nuxtOnBeforeMountCbs;r&&(O(()=>{s.forEach(u=>{u()}),s.splice(0,s.length)}),C(()=>s.splice(0,s.length)))}g&&e.isHydrating&&t in e.payload.data?n.pending.value=!1:r&&(e.payload.serverRendered&&e.isHydrating||a.lazy)?r._nuxtOnBeforeMountCbs.push(y):y(),a.watch&&P(a.watch,()=>n.refresh());const i=e.hook("app:data:refresh",s=>{if(!s||s.includes(t))return n.refresh()});r&&C(i)}const d=Promise.resolve(e._asyncDataPromises[t]).then(()=>n);return Object.assign(d,n),d}function R(o,f){const t={};for(const c of f)t[c]=o[c];return t}function H(o,f,t){const[c={},a]=typeof f=="string"?[{},f]:[f,t],e=c.key||a;if(!e||typeof e!="string")throw new TypeError("[nuxt] [useFetch] key must be a string: "+e);if(!o)throw new Error("[nuxt] [useFetch] request is missing.");const l="$f"+e,n=E(()=>{let r=o;return typeof r=="function"&&(r=r()),F(r)?r.value:r}),{server:y,lazy:g,default:d,transform:h,pick:p,watch:v,initialCache:m,..._}=c,D={..._,cache:typeof c.cache=="boolean"?void 0:c.cache},w={server:y,lazy:g,default:d,transform:h,pick:p,initialCache:m,watch:[n,...v||[]]};return A(l,()=>$fetch(n.value,D),w,"$2Qpjr020wX")}export{H as u};
